{% extends 'RednoseFrameworkBundle::layout.html.twig' %}

{% block title %}{{ model.name }}{% endblock %}

{% block content %}
    <link rel="stylesheet" href="{{ asset('yui/rednose-ui/rednose-ui/rednose-ui-min.css') }}" type="text/css" media="screen" />

    {# Include the YUI seed #}
    <script type="text/javascript" src="{{ asset('bundles/rednoseyui/3.16.0/yui/yui-min.js') }}"></script>

    {# Include the module loaders #}
    <script type="text/javascript" src="{{ asset('yui/rednose-ui/rednose-loader/rednose-loader.js') }}"></script>
    <script type="text/javascript" src="{{ asset('yui/docgen-admin/docgenadmin-loader/docgenadmin-loader.js') }}"></script>

    {# Register the loaders as part of the YUI core #}
    <script type="text/javascript">YUI.Env.core.push('rednose-loader');</script>
    <script type="text/javascript">YUI.Env.core.push('docgenadmin-loader');</script>

    {# Include the YUI config object with path and URL mappings #}
    <script>{{ rednose_yui_config() }}</script>

    {# Pass environment variables to the YUI core #}
    <script type="text/javascript">YUI.Env.user = { name: '{{ app.user.bestname }}' };</script>

    {# Assign a global YUI object to allow lazyloading #}
    <script>var Y = YUI();</script>

    <script type="text/javascript" src="{{ minify(['rednosedocgenclient/js/main.js', 'fosjsrouting/js/router.js'], 'bundles') }}"></script>
    <script type="text/javascript" src="{{ path('fos_js_routing_js', { 'callback': 'fos.Router.setData'}) }}"></script>

    <div class="container">
        {{ form(form) }}
    </div>

    <script>
        YUI().use('rednose-form', 'datatype-xml', function (Y) {
            var json = {{ json|raw }};

            function getXpathValue(document, query) {
                var result = document.evaluate(query, document, null, XPathResult.ANY_TYPE, null);

                if (result.resultType === 2) {
                    return result.stringValue;
                }

                if (result.resultType === 4) {
                    return result.iterateNext().textContent;
                }

                return null;
            }

            function getNodeXpathLocation(node) {
                var name    = node.getData('name'),
                        section = node.getData('section');

                return '//' + section + '/' + name;
            }

            function getJSONValue(data, location) {
                var tokens = location.split('.'),
                        buffer = data,
                        property;

                while (property = tokens.shift()) {
                    if (buffer === null || typeof buffer === 'undefined') {
                        return null;
                    }

                    if (!buffer.hasOwnProperty(property)) {
                        return null;
                    }

                    buffer = buffer[property];
                }

                return buffer;
            }

            function setXpathValue(document, query, value) {
                var result = document.evaluate(query, document, null, XPathResult.ANY_TYPE, null);

                if (result.resultType === 4) {
                    result.iterateNext().textContent = value;
                }
            }

            function handleConditions(document, conditions) {
                for (var nodeId in conditions) {
                    if (conditions.hasOwnProperty(nodeId)) {
                        var condition = conditions[nodeId];

                        var a = getXpathValue(document, condition.a),
                            b = getXpathValue(document, condition.b);

                        var node = Y.one('#' + nodeId),
                            row  = node.get('parentNode');

                        switch (condition.operator) {
                            case '==':
                                var result = (a === b);

                                row[result ? 'show' : 'hide']();

                                break;
                        }
                    }
                }
            }

            function handleDatasources(document, datasources) {
                for (datasourceId in datasources) {
                    if (datasources.hasOwnProperty(datasourceId)) {
                        var datasource = datasources[datasourceId];

                        form.all('[data-binding]').each(function (node) {
                            var binding = node.getData('binding'),
                                data    = {};

                            data[datasourceId] = datasource.get('record');

                            var value = getJSONValue(data, binding.replace(/[${}]/g, ''));

                            if (value) {
                                node.set('value', value);

                                setXpathValue(document, getNodeXpathLocation(node), value);
                            }
                        });
                    }
                }
            }

            var Autocomplete = Y.Rednose.ControlFormAutoComplete,
                Form         = Y.Rednose.Form.FormModel;

            var form  = Y.one('form'),
                model = new Form(json);

            var xmlData = '<' + model.get('name') + '>';

            var conditions = {};
            var datasources = {};

            model.get('sections').each(function (section) {
                xmlData += '<' + section.get('name') + '>';

                section.get('controls').each(function (control) {
                    xmlData += '<' + control.get('name') + '>';

                    var node       = form.one('[data-id=' + control.get('id') + ']'),
                        type       = control.get('type'),
                        properties = control.get('properties');

                    if (type === 'autocomplete') {
                        node.autocomplete = new Autocomplete({
                            inputNode : node,
                            choices   : (properties && properties.choices) || null,
                            datasource: (properties && properties.datasource) || null
                        }).render();
                    }

                    if (properties && properties.datasource && properties.datasource.id) {
                        datasources[properties.datasource.id] = node.autocomplete;
                    }

                    if (properties && properties.conditions && properties.conditions.visible) {
                        conditions[node.get('id')] = properties.conditions.visible;
                    }

                    xmlData += '</' + control.get('name') + '>';
                });

                xmlData += '</' + section.get('name') + '>';
            });

            xmlData += '</' + model.get('name') + '>';

            var document = Y.XML.parse(xmlData);

            form.after('change', function (e) {
                var node     = e.target,
                    location = getNodeXpathLocation(node),
                    value    = node.get('type') === 'checkbox' ? node.get('checked').toString() : node.get('value');

                setXpathValue(document, location, value);
                handleConditions(document, conditions);
                handleDatasources(document, datasources);
            });

            // Setup initial state.
            // TODO: Move to server-side setData listener.
            handleConditions(document, conditions);
        });
    </script>
{% endblock %}
